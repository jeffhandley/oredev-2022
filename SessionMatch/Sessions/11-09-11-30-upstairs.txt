 You will learn how to use gRPC in .NET in a microservice architecure
 Client-side load balancing without external tools
 Retry policies out of the box
With an increasing need for scalability and performance dictated by the modern web, it becomes harder and harder to choose an API paradigm that is suitable for service to service communication. While the classical models still work and have their own merits, some of them rely heavily on documentation, extensive coordination between teams or code-sharing. We use shared libraries, and over time our projects become intertwined with dependencies. In these cases, we need something to untangle those and reduce coupling. Welcome gRPC. gRPC has been around for a while and .NET Core 3.0 welcomes it as a first-class citizen. It is contract-based, performant - with smaller response/request bodies, perfect for polyglot environments and supports different models – from client-server, to bi-directional streaming out of the box. In this session, we will look at how to use gRPC and its 4 models and what are the benefits and or downsides of using gRPC compared to the traditional models.